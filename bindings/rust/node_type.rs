use serde::Deserialize;
use std::collections::HashMap;

#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy)]
pub enum NodeType {
    SourceFile,
    NumberSymbol,
    Identifier,
    Superscript,
    Subscript,
    SubscriptSuperscript,
    BracketExpr,
    UnaryExpr,
    UnaryFrozenExpr,
    ColorExpr,
    BinaryExpr,
    BinaryFrac,
    FactorialExpr,
    DifferentialExpr,
    SimpleExpression,
    MatrixSingleRowExpr,
    MatrixExpr,
    MatrixRowExpr, // within matrix or matrix single row
    DetExpr,
    BigEqualExpr,
    RightAssociativeExpr,
    MultilineExpr,
    LiteralString,
    LeftBracket,
    RightBracket,
    LogicSymbols,
    GreekLetters,
    MathConstants,
    SetOperators,
    MathOperators,
    AsciiEscape,
    MiscSymbols,
    UnarySymbols,
    FactorialSymbols,
    BinarySymbols,
    BinaryMidSymbols,
    DifferentialSymbols,
    SeparatorSymbols,
    BigEqualSymbols,
    UnaryFrozenSymbols,
    RightAssociativeOperators,
    MultilineBreak,
    Comma,
    Color,
    Vbar,
    Sup,
    Sub,
    Unknown,
}

impl From<&str> for NodeType {
    fn from(kind: &str) -> Self {
        match kind {
            "source_file" => NodeType::SourceFile,
            "number_symbol" => NodeType::NumberSymbol,
            "identifier" => NodeType::Identifier,
            "superscript" => NodeType::Superscript,
            "subscript" => NodeType::Subscript,
            "subscript_superscript" => NodeType::SubscriptSuperscript,
            "bracket_expr" => NodeType::BracketExpr,
            "unary_expr" => NodeType::UnaryExpr,
            "unaryFrozen_expr" => NodeType::UnaryFrozenExpr,
            "color_expr" => NodeType::ColorExpr,
            "binary_expr" => NodeType::BinaryExpr,
            "binary_frac" => NodeType::BinaryFrac,
            "factorial_expr" => NodeType::FactorialExpr,
            "differential_expr" => NodeType::DifferentialExpr,
            "simple_expression" => NodeType::SimpleExpression,
            "matrix_single_row_expr" => NodeType::MatrixSingleRowExpr,
            "matrix_expr" => NodeType::MatrixExpr,
            "matrix_row_expr" => NodeType::MatrixRowExpr,
            "det_expr" => NodeType::DetExpr,
            "bigEqual_expr" => NodeType::BigEqualExpr,
            "right_associative_expr" => NodeType::RightAssociativeExpr,
            "multiline_expr" => NodeType::MultilineExpr,
            "multi_linebreak" => NodeType::MultilineBreak,
            "literal_string" => NodeType::LiteralString,
            "left_bracket" => NodeType::LeftBracket,
            "right_bracket" => NodeType::RightBracket,
            "logic_symbols" => NodeType::LogicSymbols,
            "greek_letters" => NodeType::GreekLetters,
            "math_constants" => NodeType::MathConstants,
            "set_operators" => NodeType::SetOperators,
            "math_operators" => NodeType::MathOperators,
            "ascii_escape" => NodeType::AsciiEscape,
            "misc_symbols" => NodeType::MiscSymbols,
            "unary_symbols" => NodeType::UnarySymbols,
            "factorial_symbols" => NodeType::FactorialSymbols,
            "binary_symbols" => NodeType::BinarySymbols,
            "binary_mid_symbols" => NodeType::BinaryMidSymbols,
            "differential_symbols" => NodeType::DifferentialSymbols,
            "separator_symbols" => NodeType::SeparatorSymbols,
            "big_equal_symbols" => NodeType::BigEqualSymbols,
            "unary_frozen_symbols" => NodeType::UnaryFrozenSymbols,
            "right_associative_operators" => NodeType::RightAssociativeOperators,
            "color" => NodeType::Color,
            "," => NodeType::Comma,
            "vbar" => NodeType::Vbar,
            "^" => NodeType::Sup,
            "_" => NodeType::Sub,
            _ => NodeType::Unknown,
        }
    }
}

#[derive(Deserialize, Debug)]
pub struct SymbolConfig {
    pub logic_symbols: HashMap<String, SymbolEntry>,
    pub greek_letters: HashMap<String, SymbolEntry>,
    pub math_constants: HashMap<String, SymbolEntry>,
    pub set_operators: HashMap<String, SymbolEntry>,
    pub math_operators: HashMap<String, SymbolEntry>,
    pub ascii_escape: HashMap<String, SymbolEntry>,
    pub misc_symbols: HashMap<String, SymbolEntry>,
    pub unary_symbols: HashMap<String, SymbolEntry>,
    pub factorial_symbols: HashMap<String, SymbolEntry>,
    pub binary_symbols: HashMap<String, SymbolEntry>,
    pub binary_mid_symbols: HashMap<String, SymbolEntry>,
    pub differential_symbols: HashMap<String, SymbolEntry>,
    pub separator_symbols: HashMap<String, SymbolEntry>,
    pub big_equal_symbols: HashMap<String, SymbolEntry>,
    pub unary_frozen_symbols: HashMap<String, SymbolEntry>,
    pub right_associative_operators: HashMap<String, SymbolEntry>,
    // skipped since we just use control flow
    // number_symbol: HashMap<String, SymbolEntry>,
    // identifier: HashMap<String, SymbolEntry>,
    pub left_bracket: HashMap<String, SymbolEntry>,
    pub right_bracket: HashMap<String, SymbolEntry>,
}

#[derive(Deserialize, Debug)]
pub struct SymbolEntry {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub token: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub alias: Option<Vec<String>>,
    pub tex: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<String>,
}
